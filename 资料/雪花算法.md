## 雪花算法

![image-20230902090251444](C:\Users\35803\AppData\Roaming\Typora\typora-user-images\image-20230902090251444.png)

雪花算法id一共64个二进制位，8个字节，用long存储。

第一位为0，表示id为正数，为1就是负数了，显然id必须为正数。

接下来41位表示Unix毫秒时间戳，如果在一毫米内有很多个请求同时过来请求生成id,那么这个部分就是相同的，因为当前毫秒还没过去，毫秒时间戳是一样的。

再接下来5位是机房编号，接下来五位是机器编号，5位就只能表示32个机房，每个机房32个机器。

最后12位为自增序列号，为了保证同一毫秒内id不重复。

41位毫秒级时间戳可以使用69年，12位可以表示4096个值，即一毫米内可以生成4096个不重复id,够用了。至于那10位的机房编码和机器编码，就是固定的了。

假如一台服务器的机器编码为 00001 00001，设为机器1，机器二的机器编码为 10000 10000，假如一个请求先来到机器二，生成id为id1,之后在同一毫秒内，一个请求来到机器一，生成id为id2,因为在同一毫秒，所以id1和id2左边41位毫秒值是相同的，由于请求2后到，所以右边12位序列号比1大，但是由于机器二的机器编码比机器1大，所以id1还是比id2大，但是id1先到来，并且先存入数据库，id2后到来，后存入数据库，由于id2比id1小，所以id2需要插入到id1的前面，此时MYSQL可能会导致页分裂。

这个问题是比较明显的，但是一般同一个机房同一个机器只会操作自己的数据库，不会操作其他机器的数据库，微服务下每个服务都有自己的数据库，并且都操作自己的数据库，所以对一个数据库而言，10位机器号是固定的，只需要保证全局id不重复，不需要保证id按照先来后到的顺序按大小排序，因为同一个数据库的10位机器码固定，后来的请求12位序列号一定比前来的请求大，不会说在其他机器上生成一个id，结果发送来当前机器上存储，都是自己生成，自己存储。

时钟回拨问题，机器时间并不一定是准确的，符合现实的，假如人为调整了时间，或者机器硬件出问题导致时间回溯到之前的时间点，或者多个机器时间不是同步的，有前有后，那么就可能会产生全局重复id了。

百度全局id生成器：https://github.com/baidu/uid-generator/tree/master

美团全局id生成器：https://github.com/Meituan-Dianping/Leaf

自己实现一个，解决时间回拨，由于每台机器编码是不一样的，所以不同机器产生的id肯定不同。对于单台机器，每次保留上一次id生成的毫秒时刻信息，生成id前先进行时间比对，发现时间小于上一次时间时，当前时间戳加上两个时间差值，把时间补回到最后一次id生成的时间，即使不是真实的时间，我们保证当台机器不会产生重复id即可，不需要一定按照现实真实的时间。记录回拨次数，设置方法可以查看回拨次数，以及是否回拨过，可以人为进行清除回拨状态，重新进行所有机器时间重同步，即时间调回来之后，清除回拨记录。
